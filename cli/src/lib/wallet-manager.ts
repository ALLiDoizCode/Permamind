/**
 * Wallet Manager Module
 *
 * Handles Arweave wallet (JWK) loading, validation, keychain integration,
 * and balance checking for secure transaction signing.
 *
 * Key Features:
 * - Load JWK from file with validation
 * - System keychain integration via keytar (encrypted storage)
 * - Fallback to file-based storage with security warning
 * - Balance checking with retry logic
 * - Cross-platform support (macOS, Windows, Linux)
 */

import Arweave from 'arweave';
import { promises as fs } from 'fs';
import * as path from 'path';
import {
  FileSystemError,
  ValidationError,
} from '../types/errors.js';
import type { JWK, WalletInfo } from '../types/wallet.js';
import * as logger from '../utils/logger.js';

/**
 * Lazy-load keytar to handle optional dependency
 * Returns null if keytar is not available
 */
async function getKeytar(): Promise<typeof import('keytar') | null> {
  try {
    return await import('keytar');
  } catch (error) {
    // Keytar not available - will fall back to file-based storage
    return null;
  }
}

/**
 * Keychain service name for storing Arweave wallets
 * Used by keytar to identify this application's credentials
 */
const KEYCHAIN_SERVICE = 'agent-skills-registry';

/**
 * Prefix for keychain account names
 * Format: arweave-wallet-{identifier}
 */
const KEYCHAIN_ACCOUNT_PREFIX = 'arweave-wallet';

/**
 * Initialize Arweave SDK client for balance checks and address derivation
 */
const arweave = Arweave.init({
  host: 'arweave.net',
  port: 443,
  protocol: 'https',
});

/**
 * Derive Arweave address from JWK
 *
 * Validates that the JWK is properly formatted by deriving its public address.
 * This operation also serves as a lightweight validation check.
 *
 * @param jwk - JSON Web Key to derive address from
 * @returns 43-character base64url-encoded Arweave address
 * @throws {ValidationError} If JWK is invalid or address derivation fails
 */
async function deriveAddress(jwk: JWK): Promise<string> {
  try {
    const address = await arweave.wallets.jwkToAddress(jwk);
    return address;
  } catch (error) {
    throw new ValidationError(
      `Failed to derive Arweave address from JWK → Solution: Ensure wallet file is a valid Arweave JWK generated by Arweave SDK or ArConnect`,
      'jwk',
      'JWK structure invalid'
    );
  }
}

/**
 * Load and validate JWK from file path
 *
 * Reads a JWK file from disk, parses the JSON, validates the structure,
 * and derives the Arweave address to ensure the keypair is valid.
 *
 * @param walletPath - Absolute or relative path to JWK file
 * @returns Validated JWK object
 * @throws {FileSystemError} If wallet file doesn't exist or can't be read
 * @throws {ValidationError} If JSON is malformed or JWK structure is invalid
 *
 * @example
 * ```typescript
 * const jwk = await load('~/.arweave/wallet.json');
 * console.log('Loaded wallet:', await deriveAddress(jwk));
 * ```
 */
export async function load(walletPath: string): Promise<JWK> {
  // Validate wallet file exists before reading
  try {
    await fs.access(walletPath);
  } catch (error) {
    const filename = path.basename(walletPath);
    throw new FileSystemError(
      `Wallet file not found at ${filename} → Solution: Ensure the wallet file exists or specify the path using --wallet flag`,
      walletPath
    );
  }

  // Read wallet file
  let fileContent: string;
  try {
    fileContent = await fs.readFile(walletPath, 'utf-8');
  } catch (error) {
    const filename = path.basename(walletPath);
    throw new FileSystemError(
      `Failed to read wallet file ${filename} → Solution: Ensure you have read permissions for the wallet file`,
      walletPath
    );
  }

  // Parse JSON
  let jwk: JWK;
  try {
    jwk = JSON.parse(fileContent) as JWK;
  } catch (error) {
    const filename = path.basename(walletPath);
    throw new ValidationError(
      `Wallet file ${filename} contains malformed JSON → Solution: Ensure wallet file is a valid JSON file generated by Arweave SDK`,
      'json',
      'malformed'
    );
  }

  // Validate JWK structure has required fields
  if (!jwk.kty || !jwk.e || !jwk.n) {
    const filename = path.basename(walletPath);
    const missingFields = [];
    if (!jwk.kty) missingFields.push('kty');
    if (!jwk.e) missingFields.push('e');
    if (!jwk.n) missingFields.push('n');

    throw new ValidationError(
      `Invalid JWK format in ${filename}: missing required fields [${missingFields.join(', ')}] → Solution: Ensure wallet file is a valid Arweave JWK (JSON Web Key) generated by Arweave SDK`,
      'jwk',
      missingFields
    );
  }

  // Derive Arweave address to validate keypair
  await deriveAddress(jwk);

  return jwk;
}

/**
 * Save JWK to system keychain
 *
 * Stores the wallet in the operating system's secure credential storage:
 * - macOS: Keychain
 * - Windows: Credential Vault
 * - Linux: Secret Service API (libsecret)
 *
 * @param wallet - JWK to store securely
 * @param identifier - Unique identifier for this wallet (e.g., "main", "publisher")
 * @throws {Error} If keychain is unavailable (caller should handle gracefully)
 *
 * @example
 * ```typescript
 * await saveToKeychain(jwk, 'main');
 * ```
 */
export async function saveToKeychain(
  wallet: JWK,
  identifier: string
): Promise<void> {
  const keytar = await getKeytar();

  if (!keytar) {
    throw new Error(
      'System keychain unavailable → Solution: Install keytar package or use file-based wallet storage'
    );
  }

  const accountName = `${KEYCHAIN_ACCOUNT_PREFIX}-${identifier}`;
  const walletJson = JSON.stringify(wallet);

  try {
    await keytar.setPassword(KEYCHAIN_SERVICE, accountName, walletJson);
  } catch (error) {
    // Emit warning about keychain failure
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    logger.warn(`Failed to save wallet to keychain. Falling back to file-based storage. Error: ${errorMessage}`);
    throw error;
  }
}

/**
 * Load JWK from system keychain
 *
 * Retrieves a previously saved wallet from the OS credential storage.
 *
 * @param identifier - Unique identifier for the wallet to retrieve
 * @returns JWK if found, null if not found in keychain
 * @throws {Error} If keychain is unavailable (caller should handle gracefully)
 *
 * @example
 * ```typescript
 * const jwk = await loadFromKeychain('main');
 * if (!jwk) {
 *   console.log('Wallet not found in keychain, falling back to file');
 * }
 * ```
 */
export async function loadFromKeychain(
  identifier: string
): Promise<JWK | null> {
  const keytar = await getKeytar();

  if (!keytar) {
    // Emit warning about keychain unavailability
    logger.warn('System keychain unavailable. Using file-based wallet storage.');
    return null;
  }

  const accountName = `${KEYCHAIN_ACCOUNT_PREFIX}-${identifier}`;

  try {
    const walletJson = await keytar.getPassword(KEYCHAIN_SERVICE, accountName);

    if (walletJson === null || walletJson === undefined || walletJson === '') {
      // Not found in keychain (non-error case)
      return null;
    }

    // Parse JWK from JSON string
    const jwk: JWK = JSON.parse(walletJson) as JWK;
    return jwk;
  } catch (error) {
    // Emit warning about keychain load failure
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    logger.warn(`Failed to load wallet from keychain. Error: ${errorMessage}`);
    return null;
  }
}

/**
 * Retry a function with exponential backoff
 *
 * @param fn - Function to retry
 * @param maxAttempts - Maximum number of retry attempts (default: 3)
 * @param baseDelay - Base delay in milliseconds (default: 1000ms)
 * @returns Result from successful function execution
 * @throws Last error if all attempts fail
 * @private
 */
async function retryWithBackoff<T>(
  fn: () => Promise<T>,
  maxAttempts: number = 3,
  baseDelay: number = 1000
): Promise<T> {
  let lastError: Error | null = null;

  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));

      if (attempt < maxAttempts) {
        // Exponential backoff: 1s, 2s, 4s
        const delay = baseDelay * Math.pow(2, attempt - 1);
        // Emit retry warning
        logger.warn(`Attempt ${attempt}/${maxAttempts} failed. Retrying in ${delay}ms...`);
        await new Promise((resolve) => setTimeout(resolve, delay));
      }
    }
  }

  throw lastError ?? new Error('All retry attempts failed');
}

/**
 * Convert winston to AR
 *
 * @param winston - Balance in winston (1 AR = 1,000,000,000,000 winston)
 * @returns Human-readable AR string (e.g., "5.2 AR")
 * @private
 */
function formatBalance(winston: number): string {
  const ar = winston / 1_000_000_000_000;

  // Format with appropriate precision
  if (ar === 0) {
    return '0 AR';
  } else if (ar < 0.001) {
    return `${ar.toExponential(2)} AR`;
  } else if (ar < 1) {
    return `${ar.toFixed(6)} AR`;
  } else {
    return `${ar.toFixed(2)} AR`;
  }
}

/**
 * Check wallet balance from Arweave network
 *
 * Queries the Arweave network for the current balance of a wallet address.
 * Includes retry logic with exponential backoff for network failures.
 *
 * @param address - 43-character Arweave address to check
 * @returns WalletInfo with address, balance (winston), and formatted balance (AR)
 * @throws {AuthorizationError} If balance is insufficient for operations
 * @throws {Error} If network request fails after retries
 *
 * @example
 * ```typescript
 * const info = await checkBalance('abc123...xyz789');
 * console.log(`Balance: ${info.balanceFormatted}`);
 * ```
 */
export async function checkBalance(address: string): Promise<WalletInfo> {
  // Query balance with retry logic (3 attempts, exponential backoff)
  let balanceWinston: string;

  try {
    balanceWinston = await retryWithBackoff(async () => {
      // Set timeout for balance query (30 seconds)
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 30000);

      try {
        const balance = await arweave.wallets.getBalance(address);
        clearTimeout(timeoutId);
        return balance;
      } catch (error) {
        clearTimeout(timeoutId);
        throw error;
      }
    }, 3, 1000);
  } catch (error) {
    throw new Error(
      `Failed to query wallet balance after 3 attempts → Solution: Check network connection and try again. Error: ${error instanceof Error ? error.message : 'Unknown error'}`
    );
  }

  // Convert winston to number
  const balance = parseInt(balanceWinston, 10);

  // Format balance for human readability
  const balanceFormatted = formatBalance(balance);

  return {
    address,
    balance,
    balanceFormatted,
  };
}
