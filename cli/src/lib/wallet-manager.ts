/**
 * Wallet Manager Module
 *
 * Handles Arweave wallet (JWK) loading, validation, keychain integration,
 * and balance checking for secure transaction signing.
 *
 * Key Features:
 * - Load JWK from file with validation
 * - Generate JWK from SEED_PHRASE environment variable (deterministic)
 * - System keychain integration via keytar (encrypted storage)
 * - Fallback to file-based storage with security warning
 * - Balance checking with retry logic
 * - Cross-platform support (macOS, Windows, Linux)
 *
 * Wallet Selection Priority:
 * 1. SEED_PHRASE environment variable (highest priority)
 * 2. --wallet flag (walletPath parameter)
 * 3. Default wallet path ~/.arweave/wallet.json (fallback)
 */

import Arweave from 'arweave';
import * as path from 'path';
import * as os from 'os';
import { promises as fs } from 'fs';
import { FileSystemError, ValidationError } from '../types/errors.js';
import { WalletFactory } from './wallet-factory.js';
import type { JWK, WalletInfo } from '../types/wallet.js';
import * as logger from '../utils/logger.js';

/**
 * Lazy-load keytar to handle optional dependency
 * Returns null if keytar is not available
 */
async function getKeytar(): Promise<typeof import('keytar') | null> {
  try {
    return await import('keytar');
  } catch (error) {
    // Keytar not available - will fall back to file-based storage
    return null;
  }
}

/**
 * Default wallet path (used when no SEED_PHRASE and no --wallet flag)
 * Resolves to ~/.arweave/wallet.json on all platforms
 */
const DEFAULT_WALLET_PATH = path.join(os.homedir(), '.arweave', 'wallet.json');

/**
 * Keychain service name for storing Arweave wallets
 * Used by keytar to identify this application's credentials
 */
const KEYCHAIN_SERVICE = 'agent-skills-registry';

/**
 * Prefix for keychain account names
 * Format: arweave-wallet-{identifier}
 */
const KEYCHAIN_ACCOUNT_PREFIX = 'arweave-wallet';

/**
 * Wallet source type
 * @private
 */
type WalletSource = {
  source: 'seedPhrase' | 'file';
  value: string;
};

/**
 * Initialize Arweave SDK client for balance checks and address derivation
 */
const arweave = Arweave.init({
  host: 'arweave.net',
  port: 443,
  protocol: 'https',
});

/**
 * Determine wallet source based on priority:
 * 1. SEED_PHRASE environment variable (highest priority)
 * 2. walletPath parameter (--wallet flag)
 * 3. DEFAULT_WALLET_PATH (fallback)
 *
 * @param walletPath - Optional wallet file path from --wallet flag
 * @returns Wallet source configuration
 * @private
 */
function getWalletSource(walletPath?: string): WalletSource {
  // Priority 1: SEED_PHRASE environment variable
  const seedPhrase = process.env.SEED_PHRASE;
  if (seedPhrase && seedPhrase.trim() !== '') {
    return { source: 'seedPhrase', value: seedPhrase.trim() };
  }

  // Priority 2: --wallet flag (walletPath parameter)
  if (walletPath) {
    return { source: 'file', value: walletPath };
  }

  // Priority 3: Default wallet path
  return { source: 'file', value: DEFAULT_WALLET_PATH };
}

/**
 * Load JWK from file (internal implementation for WalletFactory)
 *
 * This function is exported for use by WalletFactory only.
 * Do not use directly - use load() instead.
 *
 * @param walletPath - Path to wallet file
 * @returns Validated JWK
 * @internal
 */
export async function loadFromFile(walletPath: string): Promise<JWK> {
  // Validate wallet file exists before reading
  try {
    await fs.access(walletPath);
  } catch (error) {
    const filename = path.basename(walletPath);
    throw new FileSystemError(
      `Wallet file not found at ${filename} → Solution: Ensure the wallet file exists or specify the path using --wallet flag`,
      walletPath
    );
  }

  // Read wallet file
  let fileContent: string;
  try {
    fileContent = await fs.readFile(walletPath, 'utf-8');
  } catch (error) {
    const filename = path.basename(walletPath);
    throw new FileSystemError(
      `Failed to read wallet file ${filename} → Solution: Ensure you have read permissions for the wallet file`,
      walletPath
    );
  }

  // Parse JSON
  let jwk: JWK;
  try {
    jwk = JSON.parse(fileContent) as JWK;
  } catch (error) {
    const filename = path.basename(walletPath);
    throw new ValidationError(
      `Wallet file ${filename} contains malformed JSON → Solution: Ensure wallet file is a valid JSON file generated by Arweave SDK`,
      'json',
      'malformed'
    );
  }

  // Validate JWK structure has required fields
  if (!jwk.kty || !jwk.e || !jwk.n) {
    const filename = path.basename(walletPath);
    const missingFields = [];
    if (!jwk.kty) missingFields.push('kty');
    if (!jwk.e) missingFields.push('e');
    if (!jwk.n) missingFields.push('n');

    throw new ValidationError(
      `Invalid JWK format in ${filename}: missing required fields [${missingFields.join(', ')}] → Solution: Ensure wallet file is a valid Arweave JWK (JSON Web Key) generated by Arweave SDK`,
      'jwk',
      missingFields
    );
  }

  return jwk;
}

/**
 * Load and validate JWK from wallet source (file or seed phrase)
 *
 * Supports multiple wallet sources with priority-based selection:
 * 1. SEED_PHRASE environment variable (highest priority)
 * 2. --wallet flag (walletPath parameter)
 * 3. Default wallet path ~/.arweave/wallet.json (fallback)
 *
 * @param walletPath - Optional path to JWK file (from --wallet flag)
 * @returns Validated JWK object
 * @throws {FileSystemError} If wallet file doesn't exist or can't be read
 * @throws {ValidationError} If JSON is malformed or JWK structure is invalid
 * @throws {InvalidMnemonicError} If SEED_PHRASE is not a valid BIP39 mnemonic
 * @throws {InvalidSeedError} If seed buffer is <32 bytes
 * @throws {JWKValidationError} If generated JWK fails Arweave SDK validation
 *
 * @example
 * ```typescript
 * // Load from SEED_PHRASE env var (Priority 1)
 * process.env.SEED_PHRASE = 'abandon abandon ... about';
 * const jwk1 = await load();
 *
 * // Load from --wallet flag (Priority 2)
 * const jwk2 = await load('/path/to/wallet.json');
 *
 * // Load from default path (Priority 3)
 * const jwk3 = await load();
 * ```
 */
export async function load(walletPath?: string): Promise<JWK> {
  const { source, value } = getWalletSource(walletPath);

  // Log wallet source (verbose mode only)
  if (source === 'seedPhrase') {
    logger.debug('Using seed phrase wallet from SEED_PHRASE environment variable');
  } else {
    logger.debug(`Using file-based wallet from ${value}`);
  }

  // Warn if both SEED_PHRASE and --wallet provided
  if (process.env.SEED_PHRASE && process.env.SEED_PHRASE.trim() !== '' && walletPath) {
    logger.warn('Both SEED_PHRASE and --wallet provided. Using SEED_PHRASE (Priority 1).');
  }

  // Load wallet using WalletFactory
  if (source === 'seedPhrase') {
    return await WalletFactory.fromSeedPhrase(value);
  } else {
    return await WalletFactory.fromFile(value);
  }
}

/**
 * Save JWK to system keychain
 *
 * Stores the wallet in the operating system's secure credential storage:
 * - macOS: Keychain
 * - Windows: Credential Vault
 * - Linux: Secret Service API (libsecret)
 *
 * Note: Keychain operations are only supported for file-based wallets.
 * Seed phrase wallets are generated deterministically and don't need keychain storage.
 *
 * @param wallet - JWK to store securely
 * @param identifier - Unique identifier for this wallet (e.g., "main", "publisher")
 * @throws {Error} If keychain is unavailable (caller should handle gracefully)
 *
 * @example
 * ```typescript
 * await saveToKeychain(jwk, 'main');
 * ```
 */
export async function saveToKeychain(
  wallet: JWK,
  identifier: string
): Promise<void> {
  // Warn if using seed phrase wallet (keychain not applicable)
  if (process.env.SEED_PHRASE && process.env.SEED_PHRASE.trim() !== '') {
    logger.warn('Keychain operations are not supported for seed phrase wallets. Seed phrase wallets are generated deterministically from SEED_PHRASE environment variable.');
  }

  const keytar = await getKeytar();

  if (!keytar) {
    throw new Error(
      'System keychain unavailable → Solution: Install keytar package or use file-based wallet storage'
    );
  }

  const accountName = `${KEYCHAIN_ACCOUNT_PREFIX}-${identifier}`;
  const walletJson = JSON.stringify(wallet);

  try {
    await keytar.setPassword(KEYCHAIN_SERVICE, accountName, walletJson);
  } catch (error) {
    // Emit warning about keychain failure
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    logger.warn(`Failed to save wallet to keychain. Falling back to file-based storage. Error: ${errorMessage}`);
    throw error;
  }
}

/**
 * Load JWK from system keychain
 *
 * Retrieves a previously saved wallet from the OS credential storage.
 *
 * Note: Keychain operations are only supported for file-based wallets.
 * If SEED_PHRASE is set, this function returns null (keychain skipped).
 *
 * @param identifier - Unique identifier for the wallet to retrieve
 * @returns JWK if found, null if not found in keychain or SEED_PHRASE is set
 * @throws {Error} If keychain is unavailable (caller should handle gracefully)
 *
 * @example
 * ```typescript
 * const jwk = await loadFromKeychain('main');
 * if (!jwk) {
 *   console.log('Wallet not found in keychain, falling back to file');
 * }
 * ```
 */
export async function loadFromKeychain(
  identifier: string
): Promise<JWK | null> {
  // Skip keychain if using seed phrase wallet
  if (process.env.SEED_PHRASE && process.env.SEED_PHRASE.trim() !== '') {
    logger.debug('Skipping keychain load: SEED_PHRASE environment variable is set');
    return null;
  }

  const keytar = await getKeytar();

  if (!keytar) {
    // Emit warning about keychain unavailability
    logger.warn('System keychain unavailable. Using file-based wallet storage.');
    return null;
  }

  const accountName = `${KEYCHAIN_ACCOUNT_PREFIX}-${identifier}`;

  try {
    const walletJson = await keytar.getPassword(KEYCHAIN_SERVICE, accountName);

    if (walletJson === null || walletJson === undefined || walletJson === '') {
      // Not found in keychain (non-error case)
      return null;
    }

    // Parse JWK from JSON string
    const jwk: JWK = JSON.parse(walletJson) as JWK;
    return jwk;
  } catch (error) {
    // Emit warning about keychain load failure
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    logger.warn(`Failed to load wallet from keychain. Error: ${errorMessage}`);
    return null;
  }
}

/**
 * Retry a function with exponential backoff
 *
 * @param fn - Function to retry
 * @param maxAttempts - Maximum number of retry attempts (default: 3)
 * @param baseDelay - Base delay in milliseconds (default: 1000ms)
 * @returns Result from successful function execution
 * @throws Last error if all attempts fail
 * @private
 */
async function retryWithBackoff<T>(
  fn: () => Promise<T>,
  maxAttempts: number = 3,
  baseDelay: number = 1000
): Promise<T> {
  let lastError: Error | null = null;

  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));

      if (attempt < maxAttempts) {
        // Exponential backoff: 1s, 2s, 4s
        const delay = baseDelay * Math.pow(2, attempt - 1);
        // Emit retry warning
        logger.warn(`Attempt ${attempt}/${maxAttempts} failed. Retrying in ${delay}ms...`);
        await new Promise((resolve) => setTimeout(resolve, delay));
      }
    }
  }

  throw lastError ?? new Error('All retry attempts failed');
}

/**
 * Convert winston to AR
 *
 * @param winston - Balance in winston (1 AR = 1,000,000,000,000 winston)
 * @returns Human-readable AR string (e.g., "5.2 AR")
 * @private
 */
function formatBalance(winston: number): string {
  const ar = winston / 1_000_000_000_000;

  // Format with appropriate precision
  if (ar === 0) {
    return '0 AR';
  } else if (ar < 0.001) {
    return `${ar.toExponential(2)} AR`;
  } else if (ar < 1) {
    return `${ar.toFixed(6)} AR`;
  } else {
    return `${ar.toFixed(2)} AR`;
  }
}

/**
 * Check wallet balance from Arweave network
 *
 * Queries the Arweave network for the current balance of a wallet address.
 * Includes retry logic with exponential backoff for network failures.
 *
 * @param address - 43-character Arweave address to check
 * @returns WalletInfo with address, balance (winston), and formatted balance (AR)
 * @throws {AuthorizationError} If balance is insufficient for operations
 * @throws {Error} If network request fails after retries
 *
 * @example
 * ```typescript
 * const info = await checkBalance('abc123...xyz789');
 * console.log(`Balance: ${info.balanceFormatted}`);
 * ```
 */
export async function checkBalance(address: string): Promise<WalletInfo> {
  // Query balance with retry logic (3 attempts, exponential backoff)
  let balanceWinston: string;

  try {
    balanceWinston = await retryWithBackoff(async () => {
      // Set timeout for balance query (30 seconds)
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 30000);

      try {
        const balance = await arweave.wallets.getBalance(address);
        clearTimeout(timeoutId);
        return balance;
      } catch (error) {
        clearTimeout(timeoutId);
        throw error;
      }
    }, 3, 1000);
  } catch (error) {
    throw new Error(
      `Failed to query wallet balance after 3 attempts → Solution: Check network connection and try again. Error: ${error instanceof Error ? error.message : 'Unknown error'}`
    );
  }

  // Convert winston to number
  const balance = parseInt(balanceWinston, 10);

  // Format balance for human readability
  const balanceFormatted = formatBalance(balance);

  return {
    address,
    balance,
    balanceFormatted,
  };
}
