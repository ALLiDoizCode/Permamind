/**
 * Wallet Manager Module
 *
 * Handles Arweave wallet (JWK) loading, validation, keychain integration,
 * and balance checking for secure transaction signing.
 *
 * Key Features:
 * - Load JWK from file with validation
 * - Generate JWK from SEED_PHRASE environment variable (deterministic)
 * - System keychain integration via keytar (encrypted storage)
 * - Fallback to file-based storage with security warning
 * - Balance checking with retry logic
 * - Cross-platform support (macOS, Windows, Linux)
 *
 * Wallet Selection Priority:
 * 1. SEED_PHRASE environment variable (highest priority)
 * 2. --wallet flag (walletPath parameter)
 * 3. Default wallet path ~/.arweave/wallet.json (fallback)
 */

import Arweave from 'arweave';
import * as path from 'path';
import * as os from 'os';
import { promises as fs } from 'fs';
import { FileSystemError, ValidationError } from '../types/errors.js';
import { WalletFactory } from './wallet-factory.js';
import {
  SeedPhraseWalletProvider,
  BrowserWalletProvider,
  FileWalletProvider,
} from './wallet-providers/index.js';
import type { JWK, WalletInfo, IWalletProvider } from '../types/wallet.js';
import * as logger from '../utils/logger.js';

/**
 * Lazy-load keytar to handle optional dependency
 * Returns null if keytar is not available
 */
async function getKeytar(): Promise<typeof import('keytar') | null> {
  try {
    return await import('keytar');
  } catch (error) {
    // Keytar not available - will fall back to file-based storage
    return null;
  }
}

/**
 * Default wallet path (used when no SEED_PHRASE and no --wallet flag)
 * Resolves to ~/.arweave/wallet.json on all platforms
 */
const DEFAULT_WALLET_PATH = path.join(os.homedir(), '.arweave', 'wallet.json');

/**
 * Keychain service name for storing Arweave wallets
 * Used by keytar to identify this application's credentials
 */
const KEYCHAIN_SERVICE = 'agent-skills-registry';

/**
 * Prefix for keychain account names
 * Format: arweave-wallet-{identifier}
 */
const KEYCHAIN_ACCOUNT_PREFIX = 'arweave-wallet';

/**
 * Wallet source type
 * Determines how the wallet is loaded and authenticated
 * @private
 */
type WalletSource = {
  source: 'seedPhrase' | 'browserWallet' | 'file';
  value: string; // Mnemonic for seedPhrase, address for browserWallet, path for file
};

/**
 * Initialize Arweave SDK client for balance checks and address derivation
 */
const arweave = Arweave.init({
  host: 'arweave.net',
  port: 443,
  protocol: 'https',
});

/**
 * Determine wallet source based on priority:
 * 1. SEED_PHRASE environment variable (highest priority)
 * 2. Browser wallet (when no SEED_PHRASE)
 * 3. --wallet flag and DEFAULT_WALLET_PATH (fallbacks when browser wallet fails)
 *
 * @param walletPath - Optional wallet file path from --wallet flag
 * @returns Wallet source configuration
 * @private
 */
function getWalletSource(_walletPath?: string): WalletSource {
  // Priority 1: SEED_PHRASE environment variable
  const seedPhrase = process.env.SEED_PHRASE;
  if (seedPhrase && seedPhrase.trim() !== '') {
    return { source: 'seedPhrase', value: seedPhrase.trim() };
  }

  // Priority 2: Browser wallet (when no SEED_PHRASE)
  // Actual connection attempt happens in load() function
  // If browser wallet fails, load() will fallback to file wallet
  return { source: 'browserWallet', value: '' };
}

/**
 * Load JWK from file (internal implementation for WalletFactory)
 *
 * This function is exported for use by WalletFactory only.
 * Do not use directly - use load() instead.
 *
 * @param walletPath - Path to wallet file
 * @returns Validated JWK
 * @internal
 */
export async function loadFromFile(walletPath: string): Promise<JWK> {
  // Validate wallet file exists before reading
  try {
    await fs.access(walletPath);
  } catch (error) {
    const filename = path.basename(walletPath);
    throw new FileSystemError(
      `Wallet file not found at ${filename} → Solution: Ensure the wallet file exists or specify the path using --wallet flag`,
      walletPath
    );
  }

  // Read wallet file
  let fileContent: string;
  try {
    fileContent = await fs.readFile(walletPath, 'utf-8');
  } catch (error) {
    const filename = path.basename(walletPath);
    throw new FileSystemError(
      `Failed to read wallet file ${filename} → Solution: Ensure you have read permissions for the wallet file`,
      walletPath
    );
  }

  // Parse JSON
  let jwk: JWK;
  try {
    jwk = JSON.parse(fileContent) as JWK;
  } catch (error) {
    const filename = path.basename(walletPath);
    throw new ValidationError(
      `Wallet file ${filename} contains malformed JSON → Solution: Ensure wallet file is a valid JSON file generated by Arweave SDK`,
      'json',
      'malformed'
    );
  }

  // Validate JWK structure has required fields
  if (!jwk.kty || !jwk.e || !jwk.n) {
    const filename = path.basename(walletPath);
    const missingFields = [];
    if (!jwk.kty) missingFields.push('kty');
    if (!jwk.e) missingFields.push('e');
    if (!jwk.n) missingFields.push('n');

    throw new ValidationError(
      `Invalid JWK format in ${filename}: missing required fields [${missingFields.join(', ')}] → Solution: Ensure wallet file is a valid Arweave JWK (JSON Web Key) generated by Arweave SDK`,
      'jwk',
      missingFields
    );
  }

  return jwk;
}

/**
 * Load wallet provider from configured source with automatic fallback
 *
 * Supports multiple wallet sources with priority-based selection:
 * 1. SEED_PHRASE environment variable (highest priority)
 * 2. Browser wallet (when no SEED_PHRASE)
 * 3. --wallet flag (fallback when browser wallet fails)
 * 4. Default wallet path ~/.arweave/wallet.json (final fallback)
 *
 * @param walletPath - Optional path to JWK file (from --wallet flag)
 * @returns Wallet provider implementing IWalletProvider interface
 * @throws {FileSystemError} If all wallet sources fail
 * @throws {ValidationError} If JSON is malformed or JWK structure is invalid
 * @throws {InvalidMnemonicError} If SEED_PHRASE is not a valid BIP39 mnemonic
 *
 * @example
 * ```typescript
 * // Load from SEED_PHRASE env var (Priority 1)
 * process.env.SEED_PHRASE = 'abandon abandon ... about';
 * const provider = await load();
 * const address = await provider.getAddress();
 *
 * // Load with browser wallet fallback (Priority 2)
 * const provider2 = await load();
 *
 * // Load from --wallet flag (Priority 3)
 * const provider3 = await load('/path/to/wallet.json');
 * ```
 */
export async function load(walletPath?: string): Promise<IWalletProvider> {
  const { source, value } = getWalletSource(walletPath);

  // Warn if both SEED_PHRASE and --wallet provided
  if (process.env.SEED_PHRASE && process.env.SEED_PHRASE.trim() !== '' && walletPath) {
    logger.warn('Both SEED_PHRASE and --wallet provided. Using SEED_PHRASE (Priority 1).');
  }

  // Priority 1: SEED_PHRASE environment variable
  if (source === 'seedPhrase') {
    logger.debug('Using seed phrase wallet from SEED_PHRASE environment variable');
    const jwk = await WalletFactory.fromSeedPhrase(value);
    return new SeedPhraseWalletProvider(jwk, value);
  }

  // Priority 2: Browser wallet (when no SEED_PHRASE)
  if (source === 'browserWallet') {
    logger.info('No SEED_PHRASE detected. Opening browser for wallet connection...');

    // Track adapter for cleanup in catch block
    let adapter: any = null;

    try {
      // Dynamic import to avoid ESM loading issues in Jest
      const { NodeArweaveWalletAdapter } = await import('./node-arweave-wallet-adapter.js');

      // Initialize browser wallet adapter
      adapter = new NodeArweaveWalletAdapter();
      await adapter.initialize({ port: 0, requestTimeout: 300000 });

      // Request connection with default permissions
      await adapter.connect(['ACCESS_ADDRESS', 'SIGN_TRANSACTION', 'DISPATCH']);

      // Get wallet address
      const address = await adapter.getAddress();
      logger.info(`Connected to wallet: ${address}`);

      return new BrowserWalletProvider(adapter, address);
    } catch (error) {
      // Browser wallet connection failed - cleanup and attempt fallback to file wallet
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.warn(`Browser wallet connection failed. Attempting fallback to file-based wallet. Error: ${errorMessage}`);

      // Cleanup adapter to release resources (prevent leaks)
      if (adapter && typeof adapter.disconnect === 'function') {
        try {
          await adapter.disconnect();
          logger.debug('Browser wallet adapter cleaned up successfully');
        } catch (disconnectError) {
          // Log warning but continue with fallback
          const disconnectMsg = disconnectError instanceof Error ? disconnectError.message : String(disconnectError);
          logger.debug(`Adapter cleanup failed (non-fatal): ${disconnectMsg}`);
        }
      }

      // Attempt fallback to file wallet (only if file exists)
      const fileWalletPath = walletPath || DEFAULT_WALLET_PATH;

      try {
        // Check if wallet file exists before attempting to load
        await fs.access(fileWalletPath);
        logger.debug(`File-based wallet found at ${fileWalletPath}, using it as fallback`);
        const jwk = await WalletFactory.fromFile(fileWalletPath);
        return new FileWalletProvider(jwk, fileWalletPath);
      } catch (fileError) {
        // File wallet doesn't exist or can't be accessed
        // Re-throw the original browser wallet error with helpful context
        const filename = path.basename(fileWalletPath);
        throw new FileSystemError(
          `No wallet available: Browser wallet connection failed and wallet file not found at ${filename}. ` +
          `Solution: Either set SEED_PHRASE environment variable or ensure ${filename} exists with a valid Arweave JWK`,
          fileWalletPath
        );
      }
    }
  }

  // Priority 3/4: File wallet (should not reach here due to getWalletSource logic, but included for safety)
  logger.debug(`Using file-based wallet from ${value}`);
  const jwk = await WalletFactory.fromFile(value);
  return new FileWalletProvider(jwk, value);
}

/**
 * Load JWK from wallet source (backward compatibility)
 *
 * @deprecated Use load() instead which returns IWalletProvider
 * This function is for backward compatibility with existing code that expects JWK.
 *
 * Note: This only works for seed phrase and file wallets (stateless JWK-based).
 * Browser wallets cannot be represented as JWK since they use remote signing.
 *
 * @param walletPath - Optional path to JWK file (from --wallet flag)
 * @returns JWK object
 * @throws {Error} If browser wallet is selected (not supported for JWK export)
 */
export async function loadJWK(walletPath?: string): Promise<JWK> {
  const provider = await load(walletPath);
  const source = provider.getSource();

  // Browser wallets cannot be exported as JWK
  if (source.source === 'browserWallet') {
    throw new Error(
      'Browser wallet cannot be exported as JWK. Use load() to get IWalletProvider instead.'
    );
  }

  // For seed phrase and file wallets, we need to reload the JWK directly
  // This is inefficient but maintains backward compatibility
  if (source.source === 'seedPhrase') {
    return await WalletFactory.fromSeedPhrase(source.value);
  } else {
    return await WalletFactory.fromFile(source.value);
  }
}

/**
 * Save JWK to system keychain
 *
 * Stores the wallet in the operating system's secure credential storage:
 * - macOS: Keychain
 * - Windows: Credential Vault
 * - Linux: Secret Service API (libsecret)
 *
 * Note: Keychain operations are only supported for file-based wallets.
 * Seed phrase wallets are generated deterministically and don't need keychain storage.
 *
 * @param wallet - JWK to store securely
 * @param identifier - Unique identifier for this wallet (e.g., "main", "publisher")
 * @throws {Error} If keychain is unavailable (caller should handle gracefully)
 *
 * @example
 * ```typescript
 * await saveToKeychain(jwk, 'main');
 * ```
 */
export async function saveToKeychain(
  wallet: JWK,
  identifier: string
): Promise<void> {
  // Warn if using seed phrase wallet (keychain not applicable)
  if (process.env.SEED_PHRASE && process.env.SEED_PHRASE.trim() !== '') {
    logger.warn('Keychain operations are not supported for seed phrase wallets. Seed phrase wallets are generated deterministically from SEED_PHRASE environment variable.');
  }

  const keytar = await getKeytar();

  if (!keytar) {
    throw new Error(
      'System keychain unavailable → Solution: Install keytar package or use file-based wallet storage'
    );
  }

  const accountName = `${KEYCHAIN_ACCOUNT_PREFIX}-${identifier}`;
  const walletJson = JSON.stringify(wallet);

  try {
    await keytar.setPassword(KEYCHAIN_SERVICE, accountName, walletJson);
  } catch (error) {
    // Emit warning about keychain failure
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    logger.warn(`Failed to save wallet to keychain. Falling back to file-based storage. Error: ${errorMessage}`);
    throw error;
  }
}

/**
 * Load JWK from system keychain
 *
 * Retrieves a previously saved wallet from the OS credential storage.
 *
 * Note: Keychain operations are only supported for file-based wallets.
 * If SEED_PHRASE is set, this function returns null (keychain skipped).
 *
 * @param identifier - Unique identifier for the wallet to retrieve
 * @returns JWK if found, null if not found in keychain or SEED_PHRASE is set
 * @throws {Error} If keychain is unavailable (caller should handle gracefully)
 *
 * @example
 * ```typescript
 * const jwk = await loadFromKeychain('main');
 * if (!jwk) {
 *   console.log('Wallet not found in keychain, falling back to file');
 * }
 * ```
 */
export async function loadFromKeychain(
  identifier: string
): Promise<JWK | null> {
  // Skip keychain if using seed phrase wallet
  if (process.env.SEED_PHRASE && process.env.SEED_PHRASE.trim() !== '') {
    logger.debug('Skipping keychain load: SEED_PHRASE environment variable is set');
    return null;
  }

  const keytar = await getKeytar();

  if (!keytar) {
    // Emit warning about keychain unavailability
    logger.warn('System keychain unavailable. Using file-based wallet storage.');
    return null;
  }

  const accountName = `${KEYCHAIN_ACCOUNT_PREFIX}-${identifier}`;

  try {
    const walletJson = await keytar.getPassword(KEYCHAIN_SERVICE, accountName);

    if (walletJson === null || walletJson === undefined || walletJson === '') {
      // Not found in keychain (non-error case)
      return null;
    }

    // Parse JWK from JSON string
    const jwk: JWK = JSON.parse(walletJson) as JWK;
    return jwk;
  } catch (error) {
    // Emit warning about keychain load failure
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    logger.warn(`Failed to load wallet from keychain. Error: ${errorMessage}`);
    return null;
  }
}

/**
 * Retry a function with exponential backoff
 *
 * @param fn - Function to retry
 * @param maxAttempts - Maximum number of retry attempts (default: 3)
 * @param baseDelay - Base delay in milliseconds (default: 1000ms)
 * @returns Result from successful function execution
 * @throws Last error if all attempts fail
 * @private
 */
async function retryWithBackoff<T>(
  fn: () => Promise<T>,
  maxAttempts: number = 3,
  baseDelay: number = 1000
): Promise<T> {
  let lastError: Error | null = null;

  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));

      if (attempt < maxAttempts) {
        // Exponential backoff: 1s, 2s, 4s
        const delay = baseDelay * Math.pow(2, attempt - 1);
        // Emit retry warning
        logger.warn(`Attempt ${attempt}/${maxAttempts} failed. Retrying in ${delay}ms...`);
        await new Promise((resolve) => setTimeout(resolve, delay));
      }
    }
  }

  throw lastError ?? new Error('All retry attempts failed');
}

/**
 * Convert winston to AR
 *
 * @param winston - Balance in winston (1 AR = 1,000,000,000,000 winston)
 * @returns Human-readable AR string (e.g., "5.2 AR")
 * @private
 */
function formatBalance(winston: number): string {
  const ar = winston / 1_000_000_000_000;

  // Format with appropriate precision
  if (ar === 0) {
    return '0 AR';
  } else if (ar < 0.001) {
    return `${ar.toExponential(2)} AR`;
  } else if (ar < 1) {
    return `${ar.toFixed(6)} AR`;
  } else {
    return `${ar.toFixed(2)} AR`;
  }
}

/**
 * Check wallet balance from Arweave network
 *
 * Queries the Arweave network for the current balance of a wallet address.
 * Includes retry logic with exponential backoff for network failures.
 *
 * @param address - 43-character Arweave address to check
 * @returns WalletInfo with address, balance (winston), and formatted balance (AR)
 * @throws {AuthorizationError} If balance is insufficient for operations
 * @throws {Error} If network request fails after retries
 *
 * @example
 * ```typescript
 * const info = await checkBalance('abc123...xyz789');
 * console.log(`Balance: ${info.balanceFormatted}`);
 * ```
 */
export async function checkBalance(address: string): Promise<WalletInfo> {
  // Query balance with retry logic (3 attempts, exponential backoff)
  let balanceWinston: string;

  try {
    balanceWinston = await retryWithBackoff(async () => {
      // Set timeout for balance query (30 seconds)
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 30000);

      try {
        const balance = await arweave.wallets.getBalance(address);
        clearTimeout(timeoutId);
        return balance;
      } catch (error) {
        clearTimeout(timeoutId);
        throw error;
      }
    }, 3, 1000);
  } catch (error) {
    throw new Error(
      `Failed to query wallet balance after 3 attempts → Solution: Check network connection and try again. Error: ${error instanceof Error ? error.message : 'Unknown error'}`
    );
  }

  // Convert winston to number
  const balance = parseInt(balanceWinston, 10);

  // Format balance for human readability
  const balanceFormatted = formatBalance(balance);

  return {
    address,
    balance,
    balanceFormatted,
  };
}
