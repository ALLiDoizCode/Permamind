# Story 6.17: hyperbeam-dynamic-reads

## Status
Draft

## Story

**As a** frontend developer,
**I want** to use HyperBEAM Dynamic Reads for read-only registry queries,
**so that** I can reduce network overhead, improve performance, and access skill data via serverless HTTP endpoints instead of message-based handlers.

## Acceptance Criteria

1. Lua transformation functions created for all read-only handlers: search-skills, get-skill, get-skill-versions, record-download, get-download-stats, info
2. Each Lua function accepts `base` (process state) and `req` (request parameters) as inputs
3. Lua functions published to Arweave with correct content-type: `application/lua`
4. HyperBEAM URLs constructed following pattern: `/{PROCESS_ID}~process@1.0/now/~lua@5.3a&module={SCRIPT_TX_ID}/{function_name}/serialize~json@1.0`
5. Frontend hyperbeamClient module created in `src/lib/hyperbeam-client.ts`
6. hyperbeamClient uses `VITE_HYPERBEAM_NODE` environment variable (default: `https://hb.randao.net`)
7. All existing React Query hooks updated to use HyperBEAM Dynamic Reads instead of dryrun
8. Backward compatibility: Fallback to dryrun if HyperBEAM request fails
9. Response parsing validates JSON structure and handles errors gracefully
10. Download tracking (record-download) implemented as fire-and-forget HTTP GET request
11. Performance improvement: HyperBEAM requests respond <500ms (vs >1s for dryrun)
12. Integration tests verify all Dynamic Reads endpoints return correct data
13. Lua transformation scripts stored in `ao-process/hyperbeam/` directory
14. Script deployment documented with Arweave transaction IDs in deployment log
15. Environment variables updated in `.env` and `.env.example` files

## Tasks / Subtasks

- [ ] Create Lua transformation functions for Dynamic Reads (AC: 1, 2)
  - [ ] Create directory `ao-process/hyperbeam/` for transformation scripts
  - [ ] Create `search-skills.lua`: Accepts query string, returns filtered skills array
    - [ ] Function signature: `function searchSkills(base, req)`
    - [ ] Parse `req.query` parameter for search term
    - [ ] Filter `base.Skills` table by name/description/tags (case-insensitive)
    - [ ] Return JSON: `{ results = [...], total = N }`
  - [ ] Create `get-skill.lua`: Accepts skill name, returns skill details
    - [ ] Function signature: `function getSkill(base, req)`
    - [ ] Parse `req.name` parameter
    - [ ] Lookup `base.Skills[name].versions[latest]`
    - [ ] Return JSON: `{ skill = {...} }` or `{ error = "Not found" }`
  - [ ] Create `get-skill-versions.lua`: Accepts skill name, returns version history
    - [ ] Function signature: `function getSkillVersions(base, req)`
    - [ ] Parse `req.name` parameter
    - [ ] Return `base.Skills[name].versions` as sorted array (latest first)
    - [ ] Return JSON: `{ versions = [...] }`
  - [ ] Create `get-download-stats.lua`: Accepts skill name, returns download count
    - [ ] Function signature: `function getDownloadStats(base, req)`
    - [ ] Parse `req.name` parameter
    - [ ] Sum `downloadCount` across all versions
    - [ ] Return JSON: `{ skillName = "...", totalDownloads = N, versions = {...} }`
  - [ ] Create `info.lua`: Returns registry process metadata
    - [ ] Function signature: `function info(base, req)`
    - [ ] Return ADP v1.0 compliant info structure
    - [ ] Return JSON: `{ process = {...}, handlers = [...], documentation = {...} }`
  - [ ] Create `list-skills.lua`: Accepts pagination/filtering params, returns skills list
    - [ ] Function signature: `function listSkills(base, req)`
    - [ ] Parse `req.limit`, `req.offset`, `req.filterTags`, `req.author`, `req.filterName`
    - [ ] Filter and paginate `base.Skills` table
    - [ ] Return JSON: `{ skills = [...], total = N, hasNextPage = bool }`

- [ ] Publish Lua scripts to Arweave (AC: 3, 14)
  - [ ] Install arx CLI globally: `npm i -g @permaweb/arx`
  - [ ] Publish `search-skills.lua` with content-type `application/lua`
    - [ ] Command: `arx upload ao-process/hyperbeam/search-skills.lua -w wallet.json --content-type application/lua`
    - [ ] Record transaction ID in `ao-process/hyperbeam/deployment-log.md`
  - [ ] Publish `get-skill.lua` with content-type `application/lua`
  - [ ] Publish `get-skill-versions.lua` with content-type `application/lua`
  - [ ] Publish `get-download-stats.lua` with content-type `application/lua`
  - [ ] Publish `info.lua` with content-type `application/lua`
  - [ ] Publish `list-skills.lua` with content-type `application/lua`
  - [ ] Create `ao-process/hyperbeam/deployment-log.md` with transaction IDs and URLs

- [ ] Create HyperBEAM client module (AC: 5, 6, 8, 9)
  - [ ] Create `frontend/src/lib/hyperbeam-client.ts`
  - [ ] Import `REGISTRY_PROCESS_ID` from `ao-client.ts`
  - [ ] Define `HYPERBEAM_NODE` constant from `VITE_HYPERBEAM_NODE` env var (default: `https://hb.randao.net`)
  - [ ] Create `buildHyperbeamUrl()` helper function
    - [ ] Parameters: `scriptTxId`, `functionName`, `queryParams` (optional)
    - [ ] Construct URL: `${HYPERBEAM_NODE}/${REGISTRY_PROCESS_ID}~process@1.0/now/~lua@5.3a&module=${scriptTxId}/${functionName}/serialize~json@1.0`
    - [ ] Append query params if provided: `?param1=value1&param2=value2`
  - [ ] Create `hyperbeamFetch()` wrapper function
    - [ ] Parameters: `url`, `fallbackFn` (optional dryrun function)
    - [ ] Try HyperBEAM fetch with timeout (5 seconds)
    - [ ] Validate JSON response structure
    - [ ] If fails and fallbackFn provided, execute fallback
    - [ ] Return parsed JSON or throw error
  - [ ] Create constants for script transaction IDs (from deployment log)
    - [ ] `SEARCH_SKILLS_SCRIPT_ID`
    - [ ] `GET_SKILL_SCRIPT_ID`
    - [ ] `GET_SKILL_VERSIONS_SCRIPT_ID`
    - [ ] `GET_DOWNLOAD_STATS_SCRIPT_ID`
    - [ ] `INFO_SCRIPT_ID`
    - [ ] `LIST_SKILLS_SCRIPT_ID`
  - [ ] Export all functions and constants

- [ ] Update React Query hooks to use HyperBEAM (AC: 7, 11)
  - [ ] Update `useSearchSkills` hook in `src/hooks/useSearchSkills.ts` (if exists) or create
    - [ ] Replace dryrun call with `hyperbeamFetch()`
    - [ ] Use `SEARCH_SKILLS_SCRIPT_ID` script
    - [ ] Pass `query` parameter in URL: `?query=${encodeURIComponent(searchTerm)}`
    - [ ] Fallback to dryrun if HyperBEAM fails
  - [ ] Update `useListSkills` hook
    - [ ] Replace dryrun call with `hyperbeamFetch()`
    - [ ] Use `LIST_SKILLS_SCRIPT_ID` script
    - [ ] Pass parameters: `?limit=${limit}&offset=${offset}&filterTags=${tags}&author=${author}&filterName=${name}`
    - [ ] Fallback to dryrun if HyperBEAM fails
  - [ ] Update `useSkillDetail` hook
    - [ ] Replace dryrun call with `hyperbeamFetch()`
    - [ ] Use `GET_SKILL_SCRIPT_ID` script
    - [ ] Pass `name` parameter: `?name=${encodeURIComponent(skillName)}`
    - [ ] Fallback to dryrun if HyperBEAM fails
  - [ ] Update `useSkillVersions` hook
    - [ ] Replace dryrun call with `hyperbeamFetch()`
    - [ ] Use `GET_SKILL_VERSIONS_SCRIPT_ID` script
    - [ ] Pass `name` parameter: `?name=${encodeURIComponent(skillName)}`
    - [ ] Fallback to dryrun if HyperBEAM fails
  - [ ] Update download stats hook (if exists, or integrate into skill detail)
    - [ ] Use `GET_DOWNLOAD_STATS_SCRIPT_ID` script
    - [ ] Pass `name` parameter
    - [ ] Fallback to dryrun if HyperBEAM fails
  - [ ] Create `useRegistryInfo` hook
    - [ ] Replace `fetchRegistryInfo()` with HyperBEAM call
    - [ ] Use `INFO_SCRIPT_ID` script
    - [ ] No parameters required
    - [ ] Fallback to dryrun if HyperBEAM fails

- [ ] Implement download tracking with Dynamic Reads (AC: 10)
  - [ ] Create `record-download.lua` transformation function
    - [ ] Function signature: `function recordDownload(base, req)`
    - [ ] Parse `req.name` parameter
    - [ ] Increment `base.Skills[name].versions[latest].downloadCount`
    - [ ] Return JSON: `{ success = true, downloadCount = N }`
    - [ ] Note: This is read-only simulation; actual increment happens via message
  - [ ] Update download tracking implementation
    - [ ] Fire-and-forget GET request to HyperBEAM endpoint
    - [ ] Do NOT await response (async fire-and-forget)
    - [ ] Log errors silently (don't block user interaction)
  - [ ] Maintain existing message-based `Record-Download` handler for state mutation
    - [ ] HyperBEAM call is for fast response, message ensures persistence

- [ ] Update environment configuration (AC: 15)
  - [ ] Verify `.env` has `VITE_HYPERBEAM_NODE=https://hb.randao.net` (already added)
  - [ ] Create/update `.env.example` with HyperBEAM configuration
    - [ ] Add comment explaining HyperBEAM Dynamic Reads
    - [ ] Add example: `VITE_HYPERBEAM_NODE=https://hb.randao.net`
  - [ ] Update TypeScript env.d.ts (if exists) with `VITE_HYPERBEAM_NODE` type

- [ ] Write integration tests (AC: 12)
  - [ ] Create `frontend/src/lib/__tests__/hyperbeam-client.test.ts`
    - [ ] Test `buildHyperbeamUrl()` constructs correct URLs
    - [ ] Test `hyperbeamFetch()` handles successful responses
    - [ ] Test `hyperbeamFetch()` fallback to dryrun on error
    - [ ] Test query parameter encoding
  - [ ] Create Playwright E2E test for HyperBEAM integration
    - [ ] Test search functionality uses HyperBEAM
    - [ ] Test skill detail page loads via HyperBEAM
    - [ ] Test version history loads via HyperBEAM
    - [ ] Verify network requests go to `hb.randao.net` (not CU/MU)
  - [ ] Performance test: Measure HyperBEAM vs dryrun response times
    - [ ] Assert HyperBEAM <500ms average
    - [ ] Compare with dryrun baseline (expect 50%+ improvement)

- [ ] Update documentation (AC: 14)
  - [ ] Create `ao-process/hyperbeam/README.md`
    - [ ] Explain HyperBEAM Dynamic Reads architecture
    - [ ] Document each transformation function
    - [ ] Provide example URLs for manual testing
    - [ ] List all script transaction IDs
  - [ ] Update `docs/architecture/tech-stack.md` (if applicable)
    - [ ] Add HyperBEAM to technology stack table
    - [ ] Category: "Data Access Layer"
    - [ ] Purpose: "Serverless read-only queries for AO process state"
    - [ ] Rationale: "Reduces network overhead, <500ms response time, server-side computation"

## Dev Notes

### HyperBEAM Dynamic Reads Architecture

**Source**: https://cookbook_ao.arweave.net/guides/hyperbeam/core/dynamic-reads.html

HyperBEAM Dynamic Reads enable "on-the-fly computations on your process state using Lua transformation functions." This shifts computational work from clients to HyperBEAM nodes, reducing network overhead and client complexity.

#### Four-Step Pipeline:
1. **State Retrieval**: Fetch latest AO process state
2. **Device Pipeline**: Pass state as `base` message to `lua@5.3a` device
3. **Script Execution**: Load and execute Lua function from Arweave transaction
4. **Result Return**: Serialize and return computed output via HTTP

#### Benefits vs Traditional Dryrun:
- **Server-side computation**: Offload processing from browsers
- **Reduced bandwidth**: Only return computed results, not raw state
- **Stateless clients**: Browsers become simple data consumers
- **Performance**: <500ms response time (vs >1s for dryrun)
- **HTTP-native**: Standard REST endpoints, no WebSocket/message passing

### Lua Transformation Function Pattern

All transformation functions follow this signature:

```lua
function functionName(base, req)
  -- base: Cached state data from AO process (Skills table)
  -- req: Incoming request object with parameters (query, name, limit, offset, etc.)

  -- Process data from base state
  local result = processLogic(base, req)

  -- Return JSON-serializable table
  return { data = result, total = count }
end
```

### HyperBEAM URL Construction

**Pattern**:
```
GET /{PROCESS_ID}~process@1.0/now/~lua@5.3a&module={SCRIPT_TX_ID}/{function_name}/serialize~json@1.0?param1=value1
```

**Components**:
- `/{PROCESS_ID}~process@1.0` - Target AO process
- `/now` - Access current state (use `/cache` for faster cached reads)
- `/~lua@5.3a&module={SCRIPT_TX_ID}` - Lua execution with script location on Arweave
- `/{function_name}` - Function to invoke from script
- `/serialize~json@1.0` - Format output as JSON
- `?param1=value1` - Optional query parameters passed to `req` object

**Example**:
```
https://hb.randao.net/0JwigA4ZGMredBmVq0M092gT5Liic_Yxv8c6T0tiFDw~process@1.0/now/~lua@5.3a&module=abc123...xyz789/searchSkills/serialize~json@1.0?query=blockchain
```

### Handlers to Replace

All these handlers are read-only and suitable for Dynamic Reads:

1. **search-skills** (Action: "Search-Skills")
   - Current: Dryrun with `Query` tag
   - HyperBEAM: `searchSkills(base, req)` with `?query=term`

2. **get-skill** (Action: "Get-Skill")
   - Current: Dryrun with `Name` tag
   - HyperBEAM: `getSkill(base, req)` with `?name=skillname`

3. **get-skill-versions** (Action: "Get-Skill-Versions")
   - Current: Dryrun with `Name` tag
   - HyperBEAM: `getSkillVersions(base, req)` with `?name=skillname`

4. **record-download** (Action: "Record-Download")
   - Current: Send message (mutable state)
   - HyperBEAM: Fire-and-forget GET for fast response, still send message for persistence

5. **get-download-stats** (Action: "Get-Download-Stats")
   - Current: Dryrun with `Name` tag
   - HyperBEAM: `getDownloadStats(base, req)` with `?name=skillname`

6. **info** (Action: "Info")
   - Current: Dryrun, no parameters
   - HyperBEAM: `info(base, req)` with no parameters

7. **list-skills** (Action: "List-Skills")
   - Current: Dryrun with `Limit`, `Offset`, `FilterTags`, `Author`, `FilterName` tags
   - HyperBEAM: `listSkills(base, req)` with query params

### Frontend Integration Strategy

**Backward Compatibility Approach**:
```typescript
async function hyperbeamFetch(url: string, fallbackFn?: () => Promise<any>) {
  try {
    const response = await fetch(url, { signal: AbortSignal.timeout(5000) });
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    const data = await response.json();
    return data;
  } catch (error) {
    console.warn('HyperBEAM failed, falling back to dryrun:', error);
    if (fallbackFn) return await fallbackFn();
    throw error;
  }
}
```

This ensures:
- Fast HyperBEAM-first approach
- Graceful degradation to dryrun if HyperBEAM unavailable
- No breaking changes to existing hooks

### Arweave Deployment with arx CLI

**Installation**:
```bash
npm i -g @permaweb/arx
```

**Upload Script**:
```bash
arx upload ao-process/hyperbeam/search-skills.lua -w wallet.json --content-type application/lua
```

**Expected Output**:
```
Uploading search-skills.lua...
Transaction ID: abc123def456ghi789...
Permanent URL: https://arweave.net/abc123def456ghi789...
```

Record transaction IDs in `deployment-log.md` for frontend configuration.

### Environment Variables

**Required**:
```bash
# .env
VITE_HYPERBEAM_NODE=https://hb.randao.net
```

**TypeScript Typing** (if using env.d.ts):
```typescript
interface ImportMetaEnv {
  readonly VITE_HYPERBEAM_NODE: string;
  // ... other env vars
}
```

### Performance Expectations

**Baseline (Current Dryrun)**:
- Average response time: 1000-1500ms
- Network overhead: Full message passing, CU processing
- Client-side parsing: JSON from Data field

**Target (HyperBEAM Dynamic Reads)**:
- Average response time: <500ms (50%+ improvement)
- Network overhead: Single HTTP GET, pre-computed JSON
- Client-side parsing: Direct JSON response

**Measurement Strategy**:
- Use `performance.now()` to measure hook execution time
- Compare HyperBEAM vs dryrun in controlled tests
- Log results to validate performance improvement

### Testing

**Unit Tests**:
- Mock `fetch` to test URL construction
- Test error handling and fallback logic
- Validate JSON parsing and type safety

**Integration Tests**:
- Use Playwright to capture network requests
- Verify requests go to `hb.randao.net`, not `ur-cu.randao.net`
- Validate response structure matches expected schema

**Performance Tests**:
- Measure average response time over 10 requests
- Assert <500ms average for HyperBEAM
- Compare with dryrun baseline

### Relevant Source Tree

```
ao-process/
├── registry.lua                    # Current AO process with handlers
└── hyperbeam/                      # NEW: Dynamic Reads scripts
    ├── README.md                   # Documentation
    ├── deployment-log.md           # Transaction IDs
    ├── search-skills.lua           # Search transformation
    ├── get-skill.lua               # Skill detail transformation
    ├── get-skill-versions.lua      # Version history transformation
    ├── get-download-stats.lua      # Download stats transformation
    ├── info.lua                    # Registry info transformation
    └── list-skills.lua             # Skills list transformation

frontend/
├── .env                            # Environment config (updated)
├── .env.example                    # NEW: Example env config
└── src/
    ├── lib/
    │   ├── ao-client.ts            # Existing dryrun client
    │   └── hyperbeam-client.ts     # NEW: HyperBEAM client
    └── hooks/
        ├── useSearchSkills.ts      # Updated to use HyperBEAM
        ├── useListSkills.ts        # Updated to use HyperBEAM
        ├── useSkillDetail.ts       # Updated to use HyperBEAM
        └── useSkillVersions.ts     # Updated to use HyperBEAM
```

### Testing

#### Unit Testing Standards
- **Location**: `frontend/src/lib/__tests__/hyperbeam-client.test.ts`
- **Framework**: Jest (from tech-stack.md)
- **Coverage**: All exported functions in hyperbeam-client.ts
- **Mocking**: Mock `fetch` API for HyperBEAM requests

**Test Cases**:
```typescript
describe('hyperbeam-client', () => {
  test('buildHyperbeamUrl constructs correct URL', () => {
    const url = buildHyperbeamUrl('scriptTxId', 'searchSkills', { query: 'test' });
    expect(url).toContain('hb.randao.net');
    expect(url).toContain('~lua@5.3a&module=scriptTxId');
    expect(url).toContain('?query=test');
  });

  test('hyperbeamFetch returns parsed JSON on success', async () => {
    global.fetch = jest.fn().mockResolvedValue({
      ok: true,
      json: async () => ({ results: [] })
    });
    const data = await hyperbeamFetch('url');
    expect(data).toEqual({ results: [] });
  });

  test('hyperbeamFetch calls fallback on error', async () => {
    global.fetch = jest.fn().mockRejectedValue(new Error('Network error'));
    const fallback = jest.fn().mockResolvedValue({ fallback: true });
    const data = await hyperbeamFetch('url', fallback);
    expect(fallback).toHaveBeenCalled();
    expect(data).toEqual({ fallback: true });
  });
});
```

#### Integration Testing Standards
- **Framework**: Playwright (from epic requirements)
- **Location**: `frontend/e2e/hyperbeam.spec.ts`
- **Coverage**: All user flows using HyperBEAM endpoints

**Test Cases**:
```typescript
test('search uses HyperBEAM endpoint', async ({ page }) => {
  // Capture network requests
  const requests = [];
  page.on('request', req => requests.push(req.url()));

  await page.goto('/');
  await page.fill('input[type="search"]', 'blockchain');
  await page.waitForResponse(resp => resp.url().includes('hb.randao.net'));

  // Verify HyperBEAM used (not CU/MU)
  expect(requests.some(url => url.includes('hb.randao.net'))).toBe(true);
  expect(requests.some(url => url.includes('ur-cu.randao.net'))).toBe(false);
});
```

#### Performance Testing
- **Tool**: Jest with `performance.now()`
- **Baseline**: Measure current dryrun response time
- **Target**: HyperBEAM <500ms average over 10 requests

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-27 | 1.0 | Initial story creation for HyperBEAM Dynamic Reads | Sarah (PO Agent) |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated by dev agent_

### Completion Notes List
_To be populated by dev agent_

### File List
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_
