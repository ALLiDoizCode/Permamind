import { z } from "zod";

import { ToolCommand, ToolContext, ToolMetadata } from "../../core/index.js";

const bmadDocOutSchema = z
  .object({
    content: z.string().describe("Content to format and output"),
    format: z
      .enum(["markdown", "html", "pdf", "json", "text"])
      .describe("Output format for document"),
    metadata: z
      .record(z.string())
      .optional()
      .describe("Additional metadata for the document"),
    title: z.string().optional().describe("Title for the document"),
  })
  .strict();

type BMADDocOutArgs = z.infer<typeof bmadDocOutSchema>;

export class BMADDocOutCommand extends ToolCommand<BMADDocOutArgs, string> {
  protected metadata: ToolMetadata = {
    description: "Document output and export in various formats",
    name: "*doc-out",
    openWorldHint: false,
    readOnlyHint: false,
    title: "BMAD Document Output",
  };

  protected parametersSchema = bmadDocOutSchema;

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  constructor(_context: ToolContext) {
    super();
  }

  async execute(args: BMADDocOutArgs, _context: ToolContext): Promise<string> {
    const { content, format, metadata, title } = args;

    try {
      return await this.formatDocument(format, content, title, metadata || {});
    } catch (error) {
      return `Error formatting document: ${error instanceof Error ? error.message : "Unknown error"}`;
    }
  }

  private async formatDocument(
    format: string,
    content: string,
    title?: string,
    metadata?: Record<string, string>,
  ): Promise<string> {
    const documentTitle = title || "Untitled Document";
    const timestamp = new Date().toISOString();
    const documentMetadata = metadata || {};

    switch (format) {
      case "html":
        return this.formatHtml(
          content,
          documentTitle,
          documentMetadata,
          timestamp,
        );
      case "json":
        return this.formatJson(
          content,
          documentTitle,
          documentMetadata,
          timestamp,
        );
      case "markdown":
        return this.formatMarkdown(
          content,
          documentTitle,
          documentMetadata,
          timestamp,
        );
      case "pdf":
        return this.formatPdf(
          content,
          documentTitle,
          documentMetadata,
          timestamp,
        );
      case "text":
        return this.formatText(
          content,
          documentTitle,
          documentMetadata,
          timestamp,
        );
      default:
        return `Unsupported format: ${format}`;
    }
  }

  private formatHtml(
    content: string,
    title: string,
    metadata: Record<string, string>,
    timestamp: string,
  ): string {
    const metadataSection =
      Object.keys(metadata).length > 0
        ? `
<div class="metadata">
<h2>Metadata</h2>
<ul>
${Object.entries(metadata)
  .map(([key, value]) => `<li><strong>${key}:</strong> ${value}</li>`)
  .join("
")}
</ul>
</div>
`
        : "";

    return `
<!DOCTYPE html>
<html>
<head>
    <title>${title}</title>
    <meta charset="UTF-8">
    <meta name="generator" content="BMAD Document Output">
    <meta name="generated" content="${timestamp}">
</head>
<body>
    <h1>${title}</h1>
    <p><strong>Generated:</strong> ${timestamp}</p>
    <p><strong>Format:</strong> HTML</p>
    ${metadataSection}
    <div class="content">
        <h2>Content</h2>
        <pre>${content}</pre>
    </div>
    <hr>
    <p><em>Generated by BMAD Document Output</em></p>
</body>
</html>
    `.trim();
  }

  private formatJson(
    content: string,
    title: string,
    metadata: Record<string, string>,
    timestamp: string,
  ): string {
    const document = {
      content,
      format: "json",
      generated: timestamp,
      generator: "BMAD Document Output",
      metadata,
      title,
    };

    return JSON.stringify(document, null, 2);
  }

  private formatMarkdown(
    content: string,
    title: string,
    metadata: Record<string, string>,
    timestamp: string,
  ): string {
    const metadataSection =
      Object.keys(metadata).length > 0
        ? `
## Metadata

${Object.entries(metadata)
  .map(([key, value]) => `- **${key}:** ${value}`)
  .join("
")}
`
        : "";

    return `
# ${title}

**Generated:** ${timestamp}
**Format:** Markdown
${metadataSection}
## Content

${content}

---
*Generated by BMAD Document Output*
    `.trim();
  }

  private formatPdf(
    content: string,
    title: string,
    metadata: Record<string, string>,
    timestamp: string,
  ): string {
    return `
# PDF Output (Preview)

**Note:** PDF generation is not yet implemented. This is a preview of what would be generated.

**Title:** ${title}
**Generated:** ${timestamp}
**Format:** PDF

## Metadata
${Object.entries(metadata)
  .map(([key, value]) => `${key}: ${value}`)
  .join("
")}

## Content
${content}

---
*This would be rendered as a PDF document*
    `.trim();
  }

  private formatText(
    content: string,
    title: string,
    metadata: Record<string, string>,
    timestamp: string,
  ): string {
    const metadataSection =
      Object.keys(metadata).length > 0
        ? `
METADATA:
${Object.entries(metadata)
  .map(([key, value]) => `${key}: ${value}`)
  .join("
")}

`
        : "";

    return `
${title}
${"=".repeat(title.length)}

Generated: ${timestamp}
Format: Plain Text

${metadataSection}CONTENT:
${content}

---
Generated by BMAD Document Output
    `.trim();
  }
}
