/* eslint-disable @typescript-eslint/no-unused-vars */
import { z } from "zod";

import {
  BmadAgentArgs,
  BmadAgentResult,
} from "../../../types/bmad-workflow.js";
import { ToolCommand, ToolContext, ToolMetadata } from "../../core/index.js";

export class InvokeAgentCommand extends ToolCommand<BmadAgentArgs, string> {
  protected metadata: ToolMetadata = {
    description:
      "Invoke specific BMad agents (analyst, pm, architect, dev, qa, po, sm) for targeted task execution with file I/O and minimal context handoffs. Agents read from context files and write outputs to specified paths for context efficiency.",
    name: "invokeAgent",
    openWorldHint: false,
    readOnlyHint: false,
    title: "Invoke BMad Agent",
  };

  protected parametersSchema = z.object({
    agentName: z
      .enum(["analyst", "pm", "architect", "dev", "qa", "po", "sm"])
      .describe("BMad agent type to invoke"),
    contextFiles: z
      .array(z.string())
      .optional()
      .describe("Optional file paths for agent context input"),
    handoffSummary: z
      .string()
      .optional()
      .describe("Optional minimal context for agent transitions"),
    outputPath: z.string().min(1).describe("Path for agent output files"),
    task: z
      .string()
      .min(1)
      .describe("Natural language task description for the agent"),
  });

  constructor(private context: ToolContext) {
    super();
  }

  async execute(args: BmadAgentArgs): Promise<string> {
    try {
      // Validate and prepare file paths
      const fs = await import("fs/promises");
      const path = await import("path");

      // Ensure output directory exists
      const outputDir = path.dirname(args.outputPath);
      await fs.mkdir(outputDir, { recursive: true });

      // Read context files if provided
      const contextData = await this.readContextFiles(args.contextFiles);

      // Execute agent-specific logic
      const result = await this.executeAgent(args, contextData);

      return JSON.stringify(result);
    } catch (error) {
      const errorResult: BmadAgentResult = {
        error: error instanceof Error ? error.message : "Unknown error",
        message: "Failed to invoke BMad agent",
        success: false,
      };

      return JSON.stringify(errorResult);
    }
  }

  private async executeAgent(
    args: BmadAgentArgs,
    contextData: string[],
  ): Promise<BmadAgentResult> {
    const fs = await import("fs/promises");
    const path = await import("path");

    // Generate agent-specific output based on agent type
    const agentOutput = await this.generateAgentOutput(args, contextData);

    // Write output to specified path
    await fs.writeFile(args.outputPath, agentOutput);

    // Generate additional files based on agent type
    const generatedFiles = await this.generateAgentArtifacts(args);

    return {
      generatedFiles: [args.outputPath, ...generatedFiles],
      message: `BMad ${args.agentName} agent executed successfully. Output written to ${args.outputPath}`,
      outputPath: args.outputPath,
      success: true,
    };
  }

  private async generateAgentArtifacts(args: BmadAgentArgs): Promise<string[]> {
    const fs = await import("fs/promises");
    const path = await import("path");

    const outputDir = path.dirname(args.outputPath);
    const generatedFiles: string[] = [];

    // Generate agent-specific artifacts
    switch (args.agentName) {
      case "analyst":
        {
          const artifactsPath = path.join(
            outputDir,
            "requirements-analysis.md",
          );
          const content = `# Requirements Analysis\n\nGenerated by BMad analyst agent for task: ${args.task}\n\n## Analysis Results\n- Business requirements documented\n- Technical constraints identified\n- Risk assessment completed`;
          await fs.writeFile(artifactsPath, content);
          generatedFiles.push(artifactsPath);
        }
        break;

      case "pm":
        {
          const artifactsPath = path.join(outputDir, "project-plan.md");
          const content = `# Project Management Plan\n\nGenerated by BMad PM agent for task: ${args.task}\n\n## Project Planning\n- Work breakdown structure created\n- Timeline and milestones established\n- Resource allocation planned`;
          await fs.writeFile(artifactsPath, content);
          generatedFiles.push(artifactsPath);
        }
        break;

      case "architect":
        {
          const artifactsPath = path.join(outputDir, "architecture-design.md");
          const content = `# System Architecture\n\nGenerated by BMad architect agent for task: ${args.task}\n\n## Architecture Overview\n- System components defined\n- Technology stack selected\n- Integration patterns documented`;
          await fs.writeFile(artifactsPath, content);
          generatedFiles.push(artifactsPath);
        }
        break;

      case "dev":
        {
          const artifactsPath = path.join(outputDir, "implementation-notes.md");
          const content = `# Development Notes\n\nGenerated by BMad dev agent for task: ${args.task}\n\n## Implementation Details\n- Code structure planned\n- Development tasks identified\n- Quality standards established`;
          await fs.writeFile(artifactsPath, content);
          generatedFiles.push(artifactsPath);
        }
        break;

      case "qa":
        {
          const artifactsPath = path.join(outputDir, "test-plan.md");
          const content = `# Quality Assurance Plan\n\nGenerated by BMad QA agent for task: ${args.task}\n\n## Testing Strategy\n- Test cases defined\n- Quality metrics established\n- Testing workflow documented`;
          await fs.writeFile(artifactsPath, content);
          generatedFiles.push(artifactsPath);
        }
        break;

      case "po":
        {
          const artifactsPath = path.join(outputDir, "product-review.md");
          const content = `# Product Owner Review\n\nGenerated by BMad PO agent for task: ${args.task}\n\n## Product Assessment\n- Requirements validation completed\n- Stakeholder feedback collected\n- Release planning initiated`;
          await fs.writeFile(artifactsPath, content);
          generatedFiles.push(artifactsPath);
        }
        break;

      case "sm":
        {
          const artifactsPath = path.join(outputDir, "process-facilitation.md");
          const content = `# Scrum Master Notes\n\nGenerated by BMad SM agent for task: ${args.task}\n\n## Process Facilitation\n- Team coordination activities\n- Impediment removal actions\n- Process improvement recommendations`;
          await fs.writeFile(artifactsPath, content);
          generatedFiles.push(artifactsPath);
        }
        break;
    }

    return generatedFiles;
  }

  private async generateAgentOutput(
    args: BmadAgentArgs,
    contextData: string[],
  ): Promise<string> {
    const timestamp = new Date().toISOString();

    let output = `# BMad ${args.agentName.toUpperCase()} Agent Output

## Task
${args.task}

## Execution Details
- **Agent**: ${args.agentName}
- **Timestamp**: ${timestamp}
- **Context Files**: ${args.contextFiles?.length || 0}

`;

    // Add handoff summary if provided
    if (args.handoffSummary) {
      output += `## Handoff Summary
${args.handoffSummary}

`;
    }

    // Add context data if available
    if (contextData.length > 0) {
      output += `## Context Data
${contextData.join("\n\n")}

`;
    }

    // Generate agent-specific content
    output += await this.generateAgentSpecificContent(args);

    return output;
  }

  private async generateAgentSpecificContent(
    args: BmadAgentArgs,
  ): Promise<string> {
    switch (args.agentName) {
      case "analyst":
        return this.generateAnalystContent(args);
      case "architect":
        return this.generateArchitectContent(args);
      case "dev":
        return this.generateDevContent(args);
      case "pm":
        return this.generatePMContent(args);
      case "po":
        return this.generatePOContent(args);
      case "qa":
        return this.generateQAContent(args);
      case "sm":
        return this.generateSMContent(args);
      default:
        return `## ${(args.agentName as string).toUpperCase()} Analysis\n\nTask: ${args.task}\n\nThis agent will analyze the task and provide recommendations based on BMad methodology.`;
    }
  }

  private generateAnalystContent(args: BmadAgentArgs): string {
    return `## Business Analysis

### Requirements Analysis
Based on the task "${args.task}", the following analysis has been performed:

#### Functional Requirements
- [ ] Identify core functionality requirements
- [ ] Define user stories and acceptance criteria
- [ ] Analyze data flow and business rules
- [ ] Document integration requirements

#### Non-Functional Requirements
- [ ] Performance and scalability requirements
- [ ] Security and compliance considerations
- [ ] Usability and accessibility standards
- [ ] Maintainability and extensibility needs

#### Risk Assessment
- [ ] Technical risks and mitigation strategies
- [ ] Business risks and contingency plans
- [ ] Resource and timeline constraints
- [ ] Dependency management

### Recommendations
1. Prioritize requirements based on business value
2. Define clear acceptance criteria for each requirement
3. Establish measurable success metrics
4. Plan for iterative development and feedback cycles

### Next Steps
- Review requirements with stakeholders
- Create detailed user stories
- Develop testing strategy
- Handoff to PM agent for project planning
`;
  }

  private generateArchitectContent(args: BmadAgentArgs): string {
    return `## System Architecture Design

### Architecture Overview
Task: ${args.task}

#### System Architecture
- [ ] Define overall system architecture and components
- [ ] Design data architecture and storage strategy
- [ ] Plan integration patterns and APIs
- [ ] Establish security architecture and protocols

#### Technical Stack
- [ ] Select appropriate technologies and frameworks
- [ ] Define development and deployment environments
- [ ] Plan for scalability and performance optimization
- [ ] Document technical standards and guidelines

#### Infrastructure Design
- [ ] Design cloud infrastructure and services
- [ ] Plan for monitoring and observability
- [ ] Establish backup and disaster recovery procedures
- [ ] Define CI/CD pipeline and deployment strategy

#### Quality Attributes
- [ ] Performance and scalability considerations
- [ ] Security and compliance requirements
- [ ] Maintainability and extensibility planning
- [ ] Reliability and availability targets

### Architecture Decisions
1. Technology selection rationale
2. Pattern selection and implementation approach
3. Trade-off analysis and decision documentation
4. Architecture evolution and migration strategy

### Next Steps
- Review architecture with technical stakeholders
- Create detailed technical specifications
- Handoff to development team
- Establish architecture governance process
`;
  }

  private generateDevContent(args: BmadAgentArgs): string {
    return `## Development Implementation

### Development Plan
Task: ${args.task}

#### Implementation Strategy
- [ ] Break down features into development tasks
- [ ] Establish coding standards and conventions
- [ ] Set up development environment and tooling
- [ ] Create development workflow and practices

#### Code Structure
- [ ] Design module and component architecture
- [ ] Implement core functionality and features
- [ ] Create reusable components and utilities
- [ ] Establish testing framework and coverage

#### Quality Assurance
- [ ] Implement unit and integration tests
- [ ] Set up code review process
- [ ] Establish continuous integration workflow
- [ ] Document code and implementation decisions

#### Technical Debt Management
- [ ] Identify and address technical debt
- [ ] Refactor code for maintainability
- [ ] Optimize performance and resource usage
- [ ] Update documentation and comments

### Development Deliverables
1. Working software increment
2. Comprehensive test suite
3. Technical documentation
4. Deployment and configuration guides

### Next Steps
- Begin implementation of core features
- Set up testing and validation processes
- Handoff to QA team for testing
- Prepare for deployment and release
`;
  }

  private generatePMContent(args: BmadAgentArgs): string {
    return `## Project Management Plan

### Project Overview
Task: ${args.task}

#### Project Scope
- [ ] Define project deliverables and outcomes
- [ ] Establish project boundaries and constraints
- [ ] Identify key stakeholders and roles
- [ ] Document success criteria and KPIs

#### Project Timeline
- [ ] Create work breakdown structure
- [ ] Estimate effort and duration for each task
- [ ] Identify critical path and dependencies
- [ ] Establish milestones and checkpoints

#### Resource Planning
- [ ] Define team composition and skills required
- [ ] Allocate resources to project phases
- [ ] Plan for knowledge transfer and training
- [ ] Establish communication protocols

#### Risk Management
- [ ] Identify project risks and impact assessment
- [ ] Develop risk mitigation strategies
- [ ] Create contingency plans
- [ ] Establish monitoring and reporting procedures

### Project Execution Strategy
1. Agile methodology with iterative development
2. Regular stakeholder communication and updates
3. Continuous integration and deployment
4. Quality assurance at each development phase

### Next Steps
- Review project plan with stakeholders
- Handoff to architect for technical design
- Establish project governance and reporting
- Begin sprint planning and team onboarding
`;
  }

  private generatePOContent(args: BmadAgentArgs): string {
    return `## Product Owner Review

### Product Evaluation
Task: ${args.task}

#### Product Validation
- [ ] Review deliverables against requirements
- [ ] Validate user stories and acceptance criteria
- [ ] Assess product value and business alignment
- [ ] Evaluate user experience and usability

#### Stakeholder Feedback
- [ ] Gather feedback from key stakeholders
- [ ] Conduct user acceptance testing sessions
- [ ] Document change requests and priorities
- [ ] Assess impact on project scope and timeline

#### Product Quality Assessment
- [ ] Evaluate product quality and performance
- [ ] Review compliance with standards and regulations
- [ ] Assess security and privacy considerations
- [ ] Document known issues and limitations

#### Release Planning
- [ ] Plan product release and rollout strategy
- [ ] Coordinate with marketing and sales teams
- [ ] Prepare user documentation and training
- [ ] Establish post-release support and maintenance

### Product Decisions
1. Product acceptance or rejection determination
2. Priority changes and scope adjustments
3. Release planning and go-to-market strategy
4. Future product roadmap and enhancements

### Next Steps
- Make final product acceptance decision
- Plan product release and communication
- Handoff to SM for release coordination
- Begin planning for next iteration or version
`;
  }

  private generateQAContent(args: BmadAgentArgs): string {
    return `## Quality Assurance Plan

### QA Strategy
Task: ${args.task}

#### Testing Strategy
- [ ] Define test scope and objectives
- [ ] Create test plans and test cases
- [ ] Establish testing environments and data
- [ ] Plan for automated and manual testing

#### Test Types
- [ ] Unit testing for individual components
- [ ] Integration testing for system interactions
- [ ] System testing for end-to-end workflows
- [ ] User acceptance testing with stakeholders

#### Quality Metrics
- [ ] Define quality gates and acceptance criteria
- [ ] Establish testing coverage requirements
- [ ] Set performance and reliability benchmarks
- [ ] Document defect tracking and resolution

#### Risk-Based Testing
- [ ] Identify high-risk areas and critical paths
- [ ] Prioritize testing based on business impact
- [ ] Plan for edge cases and error scenarios
- [ ] Establish regression testing strategy

### QA Deliverables
1. Comprehensive test plans and cases
2. Test execution reports and metrics
3. Defect reports and resolution tracking
4. Quality assessment and recommendations

### Next Steps
- Execute test plans and document results
- Report defects and work with development team
- Validate fixes and perform regression testing
- Handoff to PO for acceptance testing
`;
  }

  private generateSMContent(args: BmadAgentArgs): string {
    return `## Scrum Master Facilitation

### Process Facilitation
Task: ${args.task}

#### Team Coordination
- [ ] Facilitate team communication and collaboration
- [ ] Remove impediments and blockers
- [ ] Coordinate cross-team dependencies
- [ ] Support team self-organization and improvement

#### Process Management
- [ ] Ensure adherence to agile practices
- [ ] Facilitate sprint planning and reviews
- [ ] Conduct retrospectives and improvement planning
- [ ] Track progress and velocity metrics

#### Stakeholder Communication
- [ ] Provide regular project status updates
- [ ] Facilitate stakeholder meetings and reviews
- [ ] Manage expectations and communicate changes
- [ ] Coordinate release planning and deployment

#### Continuous Improvement
- [ ] Identify process improvement opportunities
- [ ] Facilitate team retrospectives and action planning
- [ ] Support adoption of best practices
- [ ] Monitor and report on team metrics

### Facilitation Outcomes
1. Improved team collaboration and productivity
2. Effective removal of impediments and blockers
3. Clear communication and transparency
4. Continuous process improvement and learning

### Next Steps
- Continue facilitating team processes
- Monitor project progress and team health
- Plan for next sprint or iteration
- Document lessons learned and best practices
`;
  }

  private async readContextFiles(contextFiles?: string[]): Promise<string[]> {
    if (!contextFiles || contextFiles.length === 0) {
      return [];
    }

    const fs = await import("fs/promises");
    const contextData: string[] = [];

    for (const filePath of contextFiles) {
      try {
        const content = await fs.readFile(filePath, "utf-8");
        contextData.push(`File: ${filePath}\n${content}`);
      } catch (error) {
        contextData.push(`File: ${filePath}\nError reading file: ${error}`);
      }
    }

    return contextData;
  }
}
